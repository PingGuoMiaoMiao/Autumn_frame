/// TransactionAspect - äº‹åŠ¡åˆ‡é¢
/// 
/// é€šè¿‡ AOP å®ç°å£°æ˜å¼äº‹åŠ¡æ”¯æŒ
/// 
/// ä½¿ç”¨æ–¹å¼ï¼š
/// 1. åœ¨æ–¹æ³•ä¸Šæ ‡è®° @Transactionalï¼ˆé€šè¿‡æ³¨å†Œåˆ‡é¢å®ç°ï¼‰
/// 2. è‡ªåŠ¨åœ¨æ–¹æ³•æ‰§è¡Œå‰å¼€å§‹äº‹åŠ¡
/// 3. æ–¹æ³•æ‰§è¡ŒæˆåŠŸåè‡ªåŠ¨æäº¤äº‹åŠ¡
/// 4. æ–¹æ³•æ‰§è¡Œå¼‚å¸¸æ—¶è‡ªåŠ¨å›æ»šäº‹åŠ¡

// ========== äº‹åŠ¡åˆ‡é¢å®ç° ==========

/// åˆ›å»ºäº‹åŠ¡åˆ‡é¢ï¼ˆBefore Adviceï¼‰
/// 
/// åœ¨æ–¹æ³•æ‰§è¡Œå‰å¼€å§‹äº‹åŠ¡
pub fn create_transaction_before_advice(
  transaction_manager : @Transaction.TransactionManager,
  _bean_name : String,
  definition : @Transaction.TransactionDefinition
) -> @Advice.Advice {
  @Advice.Advice::before(
    "transactionBefore",
    fn(_ctx : @hashmap.HashMap[String, String], bean_name_param : String, method_name : String, _args : Array[String]) -> String? {
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨äº‹åŠ¡ï¼ˆæ”¯æŒåµŒå¥—äº‹åŠ¡ï¼‰
      if transaction_manager.has_active_transaction(bean_name_param) {
        println("    ğŸ”µ [äº‹åŠ¡åˆ‡é¢] Bean: \{bean_name_param}, æ–¹æ³•: \{method_name}, åŠ å…¥å·²å­˜åœ¨çš„äº‹åŠ¡")
      } else {
        // å¼€å§‹æ–°äº‹åŠ¡
        let _ = transaction_manager.begin_transaction(bean_name_param, definition)
        println("    ğŸ”µ [äº‹åŠ¡åˆ‡é¢] Bean: \{bean_name_param}, æ–¹æ³•: \{method_name}, å¼€å§‹æ–°äº‹åŠ¡")
      }
      None
    },
    1  // æœ€é«˜ä¼˜å…ˆçº§ï¼Œç¡®ä¿åœ¨å…¶ä»–åˆ‡é¢ä¹‹å‰æ‰§è¡Œ
  )
}

/// åˆ›å»ºäº‹åŠ¡åˆ‡é¢ï¼ˆAfter Adviceï¼‰
/// 
/// åœ¨æ–¹æ³•æ‰§è¡ŒæˆåŠŸåæäº¤äº‹åŠ¡
pub fn create_transaction_after_advice(
  transaction_manager : @Transaction.TransactionManager,
  _bean_name : String
) -> @Advice.Advice {
  @Advice.Advice::after(
    "transactionAfter",
    fn(_ctx : @hashmap.HashMap[String, String], bean_name_param : String, method_name : String, _args : Array[String]) -> String? {
      // æäº¤äº‹åŠ¡
      transaction_manager.commit_transaction(bean_name_param)
      println("    âœ… [äº‹åŠ¡åˆ‡é¢] Bean: \{bean_name_param}, æ–¹æ³•: \{method_name}, æäº¤äº‹åŠ¡")
      None
    },
    100  // è¾ƒä½ä¼˜å…ˆçº§ï¼Œç¡®ä¿åœ¨å…¶ä»–åˆ‡é¢ä¹‹åæ‰§è¡Œ
  )
}

/// åˆ›å»ºäº‹åŠ¡åˆ‡é¢ï¼ˆAfterThrowing Adviceï¼‰
/// 
/// åœ¨æ–¹æ³•æ‰§è¡Œå¼‚å¸¸æ—¶å›æ»šäº‹åŠ¡
pub fn create_transaction_after_throwing_advice(
  transaction_manager : @Transaction.TransactionManager,
  _bean_name : String
) -> @Advice.Advice {
  @Advice.Advice::after_throwing(
    "transactionAfterThrowing",
    fn(_ctx : @hashmap.HashMap[String, String], bean_name_param : String, method_name : String, _args : Array[String]) -> String? {
      // å›æ»šäº‹åŠ¡
      transaction_manager.rollback_transaction(bean_name_param)
      println("    âŒ [äº‹åŠ¡åˆ‡é¢] Bean: \{bean_name_param}, æ–¹æ³•: \{method_name}, å›æ»šäº‹åŠ¡ï¼ˆå¼‚å¸¸ï¼‰")
      None
    },
    100  // è¾ƒä½ä¼˜å…ˆçº§
  )
}

/// ä¸º Bean çš„æ–¹æ³•æ³¨å†Œäº‹åŠ¡åˆ‡é¢
/// 
/// å‚æ•°ï¼š
/// - aop_integration: AOP é›†æˆå™¨
/// - transaction_manager: äº‹åŠ¡ç®¡ç†å™¨
/// - bean_name: Bean åç§°
/// - method_names: éœ€è¦äº‹åŠ¡æ”¯æŒçš„æ–¹æ³•åç§°åˆ—è¡¨
/// - definition: äº‹åŠ¡å®šä¹‰
pub fn register_transaction_aspect(
  aop_integration : @AopIntegration.AopIntegration,
  transaction_manager : @Transaction.TransactionManager,
  bean_name : String,
  method_names : Array[String],
  definition : @Transaction.TransactionDefinition
) -> Unit {
  // 1. æ³¨å†Œ Before Adviceï¼ˆå¼€å§‹äº‹åŠ¡ï¼‰
  let before_advice = create_transaction_before_advice(transaction_manager, bean_name, definition)
  let before_advice_name = bean_name + "_transaction_before"
  aop_integration.register_advice(before_advice_name, before_advice)
  
  // 2. æ³¨å†Œ After Adviceï¼ˆæäº¤äº‹åŠ¡ï¼‰
  let after_advice = create_transaction_after_advice(transaction_manager, bean_name)
  let after_advice_name = bean_name + "_transaction_after"
  aop_integration.register_advice(after_advice_name, after_advice)
  
  // 3. æ³¨å†Œ AfterThrowing Adviceï¼ˆå›æ»šäº‹åŠ¡ï¼‰
  let after_throwing_advice = create_transaction_after_throwing_advice(transaction_manager, bean_name)
  let after_throwing_advice_name = bean_name + "_transaction_after_throwing"
  aop_integration.register_advice(after_throwing_advice_name, after_throwing_advice)
  
  // 4. ä¸ºæ¯ä¸ªæ–¹æ³•åˆ›å»ºåˆ‡ç‚¹
  let mut i = 0
  while i < method_names.length() {
    let method_name = method_names[i]
    
    // åˆ›å»ºæ–¹æ³•ååˆ‡ç‚¹
    let pointcut_name = bean_name + "_" + method_name + "_pointcut"
    let pointcut = @Pointcut.Pointcut::method_name(pointcut_name, method_name, i + 1)
    aop_integration.register_pointcut(pointcut_name, pointcut)
    
    // åˆ›å»ºåˆ‡é¢ï¼ˆç»„åˆåˆ‡ç‚¹å’Œé€šçŸ¥ï¼‰
    // Before åˆ‡é¢
    let before_aspect = @AspectRegistry.Aspect::new(
      bean_name + "_" + method_name + "_transaction_before_aspect",
      pointcut_name,
      before_advice_name,
      i * 3 + 1
    )
    aop_integration.register_aspect(before_aspect)
    
    // After åˆ‡é¢
    let after_aspect = @AspectRegistry.Aspect::new(
      bean_name + "_" + method_name + "_transaction_after_aspect",
      pointcut_name,
      after_advice_name,
      i * 3 + 2
    )
    aop_integration.register_aspect(after_aspect)
    
    // AfterThrowing åˆ‡é¢
    let after_throwing_aspect = @AspectRegistry.Aspect::new(
      bean_name + "_" + method_name + "_transaction_after_throwing_aspect",
      pointcut_name,
      after_throwing_advice_name,
      i * 3 + 3
    )
    aop_integration.register_aspect(after_throwing_aspect)
    
    i = i + 1
  }
  
  println("  âœ… ä¸º Bean \{bean_name} æ³¨å†Œäº‹åŠ¡åˆ‡é¢ï¼ˆæ–¹æ³•æ•°é‡: \{method_names.length()}ï¼‰")
}


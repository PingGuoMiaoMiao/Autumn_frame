/// MySQLDataSource - MySQL FFI æ•°æ®æºå®ç°
/// 
/// ä½¿ç”¨ FFI è¿æ¥çœŸå® MySQL æ•°æ®åº“
/// 
/// æ³¨æ„ï¼š
/// - ä»…åœ¨ native åç«¯å¯ç”¨ï¼ˆC åç«¯ï¼‰
/// - wasm-gc åç«¯ä¸æ”¯æŒ extern "C" fn
/// - éœ€è¦ç³»ç»Ÿå®‰è£… MySQL C å®¢æˆ·ç«¯åº“ï¼ˆ-lmysqlclientï¼‰

// ========== MySQL FFI æ•°æ®æºå®ç° ==========

///|
/// MySQL æ•°æ®æºé…ç½®
pub struct MySQLDataSourceConfig {
  host : String
  port : Int
  user : String
  password : String
  database : String
} derive(Eq, Show)

///|
/// åˆ›å»º MySQL æ•°æ®æºé…ç½®
pub fn MySQLDataSourceConfig::new(
  host : String,
  port : Int,
  user : String,
  password : String,
  database : String,
) -> MySQLDataSourceConfig {
  { host, port, user, password, database }
}

///|
/// MySQL æ•°æ®æº
pub struct MySQLDataSource {
  config : MySQLDataSourceConfig
  db : Int? // MySQL æ•°æ®åº“å¥æŸ„ï¼ˆä½¿ç”¨ Int ç±»å‹ï¼‰
  is_connected : Bool
}

///|
/// åˆ›å»º MySQL æ•°æ®æº
pub fn MySQLDataSource::new(config : MySQLDataSourceConfig) -> MySQLDataSource {
  { config, db: None, is_connected: false }
}

///|
/// è¿æ¥åˆ°æ•°æ®åº“ï¼ˆMySQLï¼‰
pub fn MySQLDataSource::connect(self : MySQLDataSource) -> MySQLDataSource {
  let handle = mysql_connect_ffi(
    self.config.host,
    self.config.port,
    self.config.user,
    self.config.password,
    self.config.database,
  )
  if handle >= 0 {
    println(
      "  âœ… [MySQLæ•°æ®æº] æˆåŠŸè¿æ¥åˆ°æ•°æ®åº“: \{self.config.database}@\{self.config.host}:\{self.config.port}",
    )
    { ..self, db: Some(handle), is_connected: true }
  } else {
    println(
      "  âŒ [MySQLæ•°æ®æº] è¿æ¥æ•°æ®åº“å¤±è´¥: \{self.config.database}@\{self.config.host}:\{self.config.port}",
    )
    self
  }
}

///|
/// æ–­å¼€æ•°æ®åº“è¿æ¥
pub fn MySQLDataSource::disconnect(self : MySQLDataSource) -> MySQLDataSource {
  match self.db {
    Some(db) => {
      let _ = mysql_close_ffi(db)
      println("  âœ… [MySQLæ•°æ®æº] æ–­å¼€æ•°æ®åº“è¿æ¥")
      { ..self, db: None, is_connected: false }
    }
    None => self
  }
}

///|
/// æ‰§è¡Œ SQLï¼ˆä¸è¿”å›ç»“æœï¼‰
/// 
/// å‚æ•°ï¼š
/// - sql: SQL è¯­å¥
/// 
/// è¿”å›ï¼š
/// - Some(affected_rows): æˆåŠŸï¼Œè¿”å›å—å½±å“çš„è¡Œæ•°
/// - None: å¤±è´¥
pub fn MySQLDataSource::execute(self : MySQLDataSource, sql : String) -> Int? {
  match self.db {
    Some(db) => {
      let result = mysql_execute_ffi(db, sql)
      if result == 0 {
        println("  âœ… [MySQLæ•°æ®æº] æ‰§è¡ŒæˆåŠŸ")
        Some(1) // ç®€åŒ–å®ç°ï¼šè¿”å› 1 è¡¨ç¤ºæˆåŠŸ
      } else {
        let error_msg = mysql_errmsg_ffi(db)
        println("  âŒ [MySQLæ•°æ®æº] æ‰§è¡Œå¤±è´¥: \{error_msg}")
        None
      }
    }
    None => {
      println("  âŒ [MySQLæ•°æ®æº] æ•°æ®åº“æœªè¿æ¥")
      None
    }
  }
}

///|
/// æŸ¥è¯¢æ•°æ®ï¼ˆè¿”å›å¤šè¡Œï¼‰
/// 
/// å‚æ•°ï¼š
/// - sql: SQL æŸ¥è¯¢è¯­å¥
/// - row_mapper: è¡Œæ˜ å°„å™¨
/// 
/// è¿”å›ï¼š
/// - Some(results): æˆåŠŸï¼Œè¿”å›æ˜ å°„åçš„ç»“æœæ•°ç»„
/// - None: å¤±è´¥æˆ–æœªæ‰¾åˆ°æ•°æ®
pub fn MySQLDataSource::query(
  self : MySQLDataSource,
  sql : String,
  row_mapper : RowMapper,
) -> Array[String]? {
  println("  ğŸ” [MySQLæ•°æ®æº] å¼€å§‹æŸ¥è¯¢: " + sql)
  match self.db {
    Some(db) => {
      // ä½¿ç”¨ MySQL FFI çš„æŸ¥è¯¢æ¥å£ï¼ˆè¿”å› FixedArray[String]ï¼‰
      let empty_params : Array[String] = []
      println(
        "  ğŸ” [MySQLæ•°æ®æº] è°ƒç”¨ mysql_query_ffi, handle=" +
        db.to_string(),
      )
      let fixed_results = mysql_query_ffi(db, sql, empty_params)
      println(
        "  ğŸ” [MySQLæ•°æ®æº] æŸ¥è¯¢å®Œæˆ, FixedArray ç»“æœæ•°é‡=" +
        fixed_results.length().to_string(),
      )

      // å°† FixedArray[String] è½¬æ¢ä¸º Array[String]
      // æ ¹æ® MoonBit Array Package æ–‡æ¡£ï¼Œä½¿ç”¨ Array::from_iter ä» FixedArray çš„è¿­ä»£å™¨åˆ›å»º Array
      let results = Array::from_iter(fixed_results.iter())
      println(
        "  ğŸ” [MySQLæ•°æ®æº] è½¬æ¢ä¸º Array å, ç»“æœæ•°é‡=" +
        results.length().to_string(),
      )
      if results.length() > 0 {
        // è½¬æ¢ç»“æœï¼šå¤„ç†æ‰€æœ‰è¡Œ
        let result : Array[String] = []
        let result_mut = result
        let mut i = 0
        while i < results.length() {
          let row_str = results[i]
          // è§£æè¡Œæ•°æ®ï¼ˆæ ¼å¼ï¼škey1=value1\tkey2=value2ï¼‰
          let row : @hashmap.HashMap[String, String] = @hashmap.new()
          // è§£æè¡Œå­—ç¬¦ä¸²ï¼ˆåˆ¶è¡¨ç¬¦åˆ†éš”çš„ key=value å¯¹ï¼‰
          // split è¿”å› Iter[StringView]ï¼Œéœ€è¦è½¬æ¢ä¸ºæ•°ç»„
          let tab_str = "\t"
          let parts_iter = row_str.split(tab_str)
          let parts_array = parts_iter.to_array()
          let mut j = 0
          while j < parts_array.length() {
            let part = parts_array[j]
            // åˆ†å‰² key=value
            let eq_str = "="
            let kv_iter = part.split(eq_str)
            let kv_array = kv_iter.to_array()
            if kv_array.length() >= 2 {
              let key = kv_array[0].to_string()
              let value = kv_array[1].to_string()
              row.set(key, value)
            }
            j = j + 1
          }
          result_mut.push(row_mapper(row))
          i = i + 1
        }
        Some(result_mut)
      } else {
        None
      }
    }
    None => {
      println("  âŒ [MySQLæ•°æ®æº] æ•°æ®åº“æœªè¿æ¥")
      None
    }
  }
}

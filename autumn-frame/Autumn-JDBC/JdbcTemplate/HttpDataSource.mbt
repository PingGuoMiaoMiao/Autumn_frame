/// HttpDataSource - HTTP æ•°æ®æºå®ç°
/// 
/// é€šè¿‡ HTTP API è®¿é—®æ•°æ®åº“ï¼Œé€‚ç”¨äº WebAssembly ç¯å¢ƒ
/// 
/// ä½¿ç”¨æ–¹å¼ï¼š
/// 1. åç«¯éœ€è¦æä¾› HTTP API æœåŠ¡ï¼ˆå¦‚ï¼šSpring Boot + JPAï¼‰
/// 2. å‰ç«¯ Moonbit åº”ç”¨é€šè¿‡ HTTP è°ƒç”¨åç«¯ API
/// 3. åç«¯å¤„ç†å®é™…çš„æ•°æ®åº“æ“ä½œ
/// 
/// ä¼˜ç‚¹ï¼š
/// - âœ… ä¸éœ€è¦æ•°æ®åº“é©±åŠ¨
/// - âœ… é€‚ç”¨äº WebAssembly ç¯å¢ƒ
/// - âœ… å¯ä»¥è¿æ¥åˆ°ä»»ä½•æ”¯æŒ HTTP çš„åç«¯
/// - âœ… æ˜“äºè·¨å¹³å°éƒ¨ç½²
/// 
/// æ³¨æ„ï¼š
/// - Moonbit çš„ HTTP å®¢æˆ·ç«¯æ˜¯ async çš„
/// - å®é™…ä½¿ç”¨æ—¶éœ€è¦åœ¨ async ç¯å¢ƒä¸­è°ƒç”¨
/// - å½“å‰å®ç°æä¾›åŒæ­¥æ¥å£ï¼ˆç”¨äºæ¼”ç¤ºï¼‰ï¼Œå®é™…éœ€è¦ async ç‰ˆæœ¬

// ========== å¯¼å…¥ä¾èµ– ==========

// ä» RowMapper æ¨¡å—å¯¼å…¥ç±»å‹ï¼ˆåŒä¸€åŒ…å†…ï¼Œç›´æ¥ä½¿ç”¨ï¼‰
// æ³¨æ„ï¼šRowMapper å’Œ Row åœ¨ RowMapper.mbt ä¸­å·²å®šä¹‰

// ========== HTTP æ•°æ®æºå®ç° ==========

///|
/// HTTP æ•°æ®æºé…ç½®
pub struct HttpDataSourceConfig {
  base_url : String // åç«¯ API åŸºç¡€ URL
  timeout : Int // è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  headers : @hashmap.HashMap[String, String] // è‡ªå®šä¹‰è¯·æ±‚å¤´
} derive(Eq, Show)

///|
/// åˆ›å»º HTTP æ•°æ®æºé…ç½®
pub fn HttpDataSourceConfig::new(base_url : String) -> HttpDataSourceConfig {
  {
    base_url,
    timeout: 5000, // é»˜è®¤ 5 ç§’
    headers: @hashmap.new(),
  }
}

///|
/// HTTP æ•°æ®æº
/// 
/// å®ç°è¯´æ˜ï¼š
/// 1. å½“å‰æä¾›åŒæ­¥æ¥å£ï¼ˆç”¨äºæ¼”ç¤ºå’Œå…¼å®¹æ€§ï¼‰
/// 2. å®é™…æ‰§è¡Œéœ€è¦ async ç¯å¢ƒï¼ˆä½¿ç”¨ moonbitlang/async/httpï¼‰
/// 3. å¯ä»¥é›†æˆåˆ° async çš„ JdbcTemplate ä¸­
pub struct HttpDataSource {
  config : HttpDataSourceConfig
  // æ³¨æ„ï¼šå®é™…ä½¿ç”¨æ—¶éœ€è¦ HTTP å®¢æˆ·ç«¯
  // ä½†ç”±äº Moonbit HTTP å®¢æˆ·ç«¯æ˜¯ async çš„ï¼Œè¿™é‡Œæš‚ä¸å­˜å‚¨å®¢æˆ·ç«¯å®ä¾‹
  // æ¯æ¬¡è¯·æ±‚æ—¶åˆ›å»ºæ–°çš„è¿æ¥
}

///|
/// åˆ›å»º HTTP æ•°æ®æº
pub fn HttpDataSource::new(config : HttpDataSourceConfig) -> HttpDataSource {
  { config, }
}

///|
/// é€šè¿‡ HTTP API æ‰§è¡Œ SQLï¼ˆä¸è¿”å›ç»“æœï¼‰
/// 
/// API æ¥å£è®¾è®¡ï¼š
/// 1. POST /api/db/execute
/// 2. Body: {"sql": "...", "params": [...]}
/// 3. Response: {"affected_rows": 1, "success": true}
/// 
/// æ³¨æ„ï¼šè¿™æ˜¯åŒæ­¥ç‰ˆæœ¬ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
/// å®é™…ä½¿ç”¨è¯·ä½¿ç”¨ async_executeï¼ˆéœ€è¦ async ç¯å¢ƒï¼‰
pub fn HttpDataSource::execute(
  self : HttpDataSource,
  sql : String,
  params : Array[String],
) -> Int {
  println("  ğŸŒ [HTTPæ•°æ®æº] æ‰§è¡Œ SQL: \{sql}")
  println("  ğŸ“‹ [HTTPæ•°æ®æº] å‚æ•°: \{params.length()} ä¸ª")
  println(
    "  ğŸ”— [HTTPæ•°æ®æº] è¯·æ±‚ URL: \{self.config.base_url}/api/db/execute",
  )
  println(
    "  âš ï¸  [HTTPæ•°æ®æº] å½“å‰æ˜¯æ¼”ç¤ºæ¨¡å¼ï¼Œå®é™…éœ€è¦ä½¿ç”¨ async_execute",
  )

  // æ³¨æ„ï¼šå®é™…å®ç°éœ€è¦ä½¿ç”¨ async HTTP å®¢æˆ·ç«¯
  // ç¤ºä¾‹ä»£ç ï¼ˆéœ€è¦åœ¨ async ç¯å¢ƒä¸­ï¼‰ï¼š
  // 
  // use @async/http/send.{post}
  // use @async/http/types.{Protocol}
  // use @buffer.{Buffer}
  // 
  // let json_body = {
  //   "sql": sql,
  //   "params": params
  // }.to_json_string()
  // 
  // let body_data = @buffer.Buffer::new()
  // body_data.write_string_utf8(json_body)
  // 
  // let (response, body) = await post(
  //   self.config.base_url + "/api/db/execute",
  //   headers = {"Content-Type": "application/json"},
  //   body = body_data.contents()
  // )
  // 
  // if response.code == 200 {
  //   let json = parse_json(body.to_string())
  //   json.get_int("affected_rows").or(0)
  // } else {
  //   0
  // }

  // æ¼”ç¤ºæ¨¡å¼ï¼šè¿”å›æ¨¡æ‹Ÿå€¼
  1
}

///|
/// é€šè¿‡ HTTP API æ‰§è¡Œ SQLï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰
/// 
/// æ³¨æ„ï¼šè¿™éœ€è¦åœ¨ async ç¯å¢ƒä¸­è°ƒç”¨
/// ä½¿ç”¨ç¤ºä¾‹ï¼š
/// ```moonbit
/// async fn example() {
///   let data_source = HttpDataSource::new(HttpDataSourceConfig::new("http://localhost:8080"))
///   let rows = data_source.async_execute("INSERT INTO users (name) VALUES (?)", ["test"])
///   println("å½±å“è¡Œæ•°: \{rows}")
/// }
/// ```
/// 
/// å®é™…å®ç°éœ€è¦ï¼š
/// 1. ä½¿ç”¨ moonbitlang/async/http çš„ post å‡½æ•°
/// 2. åºåˆ—åŒ– JSON è¯·æ±‚ä½“
/// 3. è§£æ JSON å“åº”
/// 4. å¤„ç†é”™è¯¯
pub async fn HttpDataSource::async_execute(
  self : HttpDataSource,
  sql : String,
  params : Array[String],
) -> Int {
  // æ„å»º JSON è¯·æ±‚ä½“
  let json_body = build_json_request(sql, params)
  let url = self.config.base_url + "/api/db/execute"
  println("  ğŸŒ [HTTPæ•°æ®æº] å‘é€ POST è¯·æ±‚åˆ°: \{url}")
  println("  ğŸ“ [HTTPæ•°æ®æº] è¯·æ±‚ä½“: \{json_body}")

  // æ³¨æ„ï¼šå®Œæ•´çš„å®ç°éœ€è¦ä½¿ç”¨ moonbitlang/async/http å®¢æˆ·ç«¯
  // ç¤ºä¾‹ä»£ç ï¼ˆéœ€è¦åœ¨å®Œæ•´çš„ async ç¯å¢ƒä¸­ï¼‰ï¼š
  // 
  // use @http.{post}
  // use @buffer.{Buffer}
  // 
  // let body_buffer = @buffer.Buffer::new()
  // body_buffer.write_string_utf8(json_body)
  // 
  // let mut headers : @hashmap.HashMap[String, String] = @hashmap.new()
  // headers.set("Content-Type", "application/json")
  // self.config.headers.iter().each(fn(entry : (String, String)) {
  //   let (k, v) = entry
  //   headers.set(k, v)
  // })
  // 
  // let (response, body_reader) = await post(url, headers, body_buffer.contents())
  // 
  // if response.code == 200 {
  //   let body_str = body_reader.to_string()
  //   match parse_json_response(body_str) {
  //     Some(json) => {
  //       match json.get("affected_rows") {
  //         Some(value_str) => {
  //           // ç®€åŒ–ï¼šç›´æ¥è§£ææ•´æ•°
  //           parse_int(value_str).or(0)
  //         }
  //         None => 0
  //       }
  //     }
  //     None => 0
  //   }
  // } else {
  //   println("  âŒ [HTTPæ•°æ®æº] è¯·æ±‚å¤±è´¥: \{response.code} \{response.reason}")
  //   0
  // }

  // å½“å‰å®ç°ï¼šä½¿ç”¨ç®€åŒ–çš„ JSON è§£æ
  // å®é™…ç¯å¢ƒä¸­ï¼Œè¿™åº”è¯¥é€šè¿‡ HTTP å®¢æˆ·ç«¯è·å–çœŸå®çš„å“åº”
  let mock_response = "{\"affected_rows\":1,\"success\":true}"
  match parse_json_response(mock_response) {
    Some(json) =>
      match json.get("affected_rows") {
        Some(value) =>
          // ç®€åŒ–ï¼šå‡è®¾å€¼æ˜¯æ•°å­—å­—ç¬¦ä¸²
          match parse_int(value) {
            Some(num) => num
            None => 1
          }
        None => 1
      }
    None => 1
  }
}

///|
/// è§£ææ•´æ•°ï¼ˆç®€åŒ–å®ç°ï¼‰
fn parse_int(s : String) -> Int? {
  let mut result = 0
  let mut i = 0
  let mut negative = false
  if s.length() > 0 && s[0] == '-' {
    negative = true
    i = 1
  }
  while i < s.length() {
    let c = s[i]
    if c >= '0' && c <= '9' {
      result = result * 10 + (c - '0')
      i = i + 1
    } else {
      break
    }
  }
  if i > (if negative { 1 } else { 0 }) {
    Some(if negative { -result } else { result })
  } else {
    None
  }
}

///|
/// é€šè¿‡ HTTP API æŸ¥è¯¢æ•°æ®ï¼ˆåŒæ­¥ç‰ˆæœ¬ï¼Œç”¨äºæ¼”ç¤ºï¼‰
/// 
/// API æ¥å£è®¾è®¡ï¼š
/// 1. POST /api/db/query
/// 2. Body: {"sql": "...", "params": [...]}
/// 3. Response: {"rows": [{"col1": "val1", "col2": "val2"}, ...]}
/// 
/// å®é™…ä½¿ç”¨è¯·ä½¿ç”¨ async_queryï¼ˆéœ€è¦ async ç¯å¢ƒï¼‰
pub fn HttpDataSource::query(
  self : HttpDataSource,
  sql : String,
  params : Array[String],
  row_mapper : RowMapper,
) -> String? {
  println("  ğŸŒ [HTTPæ•°æ®æº] æŸ¥è¯¢ SQL: \{sql}")
  println("  ğŸ“‹ [HTTPæ•°æ®æº] å‚æ•°: \{params.length()} ä¸ª")
  println(
    "  ğŸ”— [HTTPæ•°æ®æº] è¯·æ±‚ URL: \{self.config.base_url}/api/db/query",
  )
  println(
    "  âš ï¸  [HTTPæ•°æ®æº] å½“å‰æ˜¯æ¼”ç¤ºæ¨¡å¼ï¼Œå®é™…éœ€è¦ä½¿ç”¨ async_query",
  )

  // æ¼”ç¤ºæ¨¡å¼ï¼šè¿”å›æ¨¡æ‹Ÿæ•°æ®
  let mock_row : @hashmap.HashMap[String, String] = @hashmap.new()
  mock_row.set("id", "1")
  mock_row.set("name", "test")
  Some(row_mapper(mock_row))
}

///|
/// é€šè¿‡ HTTP API æŸ¥è¯¢æ•°æ®ï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰
/// 
/// å®é™…å®ç°éœ€è¦ï¼š
/// 1. å‘é€ HTTP POST è¯·æ±‚åˆ° /api/db/query
/// 2. è§£æ JSON å“åº”
/// 3. å°†ç¬¬ä¸€è¡Œè½¬æ¢ä¸º HashMap
/// 4. ä½¿ç”¨ row_mapper æ˜ å°„
pub async fn HttpDataSource::async_query(
  self : HttpDataSource,
  sql : String,
  params : Array[String],
  row_mapper : RowMapper,
) -> String? {
  // æ„å»º JSON è¯·æ±‚ä½“
  let json_body = build_json_request(sql, params)
  let url = self.config.base_url + "/api/db/query"
  println("  ğŸŒ [HTTPæ•°æ®æº] å‘é€æŸ¥è¯¢è¯·æ±‚åˆ°: \{url}")
  println("  ğŸ“ [HTTPæ•°æ®æº] è¯·æ±‚ä½“: \{json_body}")

  // å½“å‰å®ç°ï¼šä½¿ç”¨ç®€åŒ–çš„ JSON è§£æ
  // å®é™…ç¯å¢ƒä¸­ï¼Œè¿™åº”è¯¥é€šè¿‡ HTTP å®¢æˆ·ç«¯è·å–çœŸå®çš„å“åº”
  let mock_response = "{\"rows\":[{\"id\":\"1\",\"name\":\"test\"}]}"
  match parse_json_response(mock_response) {
    Some(_json) => {
      // ç®€åŒ–ï¼šç›´æ¥åˆ›å»ºæ¨¡æ‹Ÿè¡Œ
      // å®Œæ•´å®ç°éœ€è¦è§£æ rows æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
      let mock_row : @hashmap.HashMap[String, String] = @hashmap.new()
      mock_row.set("id", "1")
      mock_row.set("name", "test")
      Some(row_mapper(mock_row))
    }
    None => None
  }
}

///|
/// é€šè¿‡ HTTP API æ‰¹é‡æ‰§è¡Œ SQLï¼ˆåŒæ­¥ç‰ˆæœ¬ï¼Œç”¨äºæ¼”ç¤ºï¼‰
/// 
/// API æ¥å£è®¾è®¡ï¼š
/// 1. POST /api/db/batch
/// 2. Body: {"sql": "...", "params_list": [[...], [...]]}
/// 3. Response: {"affected_rows": [1, 1, 1]}
/// 
/// å®é™…ä½¿ç”¨è¯·ä½¿ç”¨ async_batch_executeï¼ˆéœ€è¦ async ç¯å¢ƒï¼‰
pub fn HttpDataSource::batch_execute(
  self : HttpDataSource,
  sql : String,
  params_list : Array[Array[String]],
) -> Array[Int] {
  println("  ğŸŒ [HTTPæ•°æ®æº] æ‰¹é‡æ‰§è¡Œ SQL: \{sql}")
  println("  ğŸ“‹ [HTTPæ•°æ®æº] æ‰¹æ¬¡æ•°é‡: \{params_list.length()}")
  println(
    "  ğŸ”— [HTTPæ•°æ®æº] è¯·æ±‚ URL: \{self.config.base_url}/api/db/batch",
  )
  println(
    "  âš ï¸  [HTTPæ•°æ®æº] å½“å‰æ˜¯æ¼”ç¤ºæ¨¡å¼ï¼Œå®é™…éœ€è¦ä½¿ç”¨ async_batch_execute",
  )

  // æ¼”ç¤ºæ¨¡å¼ï¼šè¿”å›æ¨¡æ‹Ÿå€¼
  let result : Array[Int] = []
  let mut i = 0
  while i < params_list.length() {
    result.push(1)
    i = i + 1
  }
  result
}

///|
/// é€šè¿‡ HTTP API æ‰¹é‡æ‰§è¡Œ SQLï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰
/// 
/// API æ¥å£è®¾è®¡ï¼š
/// 1. POST /api/db/batch
/// 2. Body: {"sql": "...", "params_list": [[...], [...]]}
/// 3. Response: {"affected_rows": [1, 1, 1]}
pub async fn HttpDataSource::async_batch_execute(
  self : HttpDataSource,
  sql : String,
  params_list : Array[Array[String]],
) -> Array[Int] {
  // æ„å»º JSON è¯·æ±‚ä½“ï¼ˆåŒ…å«å‚æ•°åˆ—è¡¨ï¼‰
  // ä½¿ç”¨å¾ªç¯è€Œä¸æ˜¯é—­åŒ…æ¥é¿å…å¯å˜å˜é‡æ•è·é—®é¢˜
  let json_start = "{\"sql\":\"" +
    escape_json_string(sql) +
    "\",\"params_list\":["
  let mut json = json_start
  let mut batch_idx = 0
  while batch_idx < params_list.length() {
    if batch_idx > 0 {
      json = json + ","
    }
    json = json + "["
    let params = params_list[batch_idx]
    let mut param_idx = 0
    while param_idx < params.length() {
      if param_idx > 0 {
        json = json + ","
      }
      json = json + "\"" + escape_json_string(params[param_idx]) + "\""
      param_idx = param_idx + 1
    }
    json = json + "]"
    batch_idx = batch_idx + 1
  }
  json = json + "]}"
  let url = self.config.base_url + "/api/db/batch"
  println("  ğŸŒ [HTTPæ•°æ®æº] å‘é€æ‰¹é‡è¯·æ±‚åˆ°: \{url}")
  println("  ğŸ“ [HTTPæ•°æ®æº] æ‰¹æ¬¡æ•°é‡: \{params_list.length()}")

  // å½“å‰å®ç°ï¼šè¿”å›æ¨¡æ‹Ÿå€¼
  // å®Œæ•´å®ç°éœ€è¦è§£æå“åº”çš„ affected_rows æ•°ç»„
  let result : Array[Int] = []
  let result_mut = result
  let mut i = 0
  while i < params_list.length() {
    result_mut.push(1)
    i = i + 1
  }
  result_mut
}

// ========== å·¥å…·å‡½æ•° ==========

///|
/// æ„å»º JSON è¯·æ±‚ä½“ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰
/// 
/// å®ç°åŸºæœ¬çš„ JSON åºåˆ—åŒ–ï¼ˆè½¬ä¹‰ç‰¹æ®Šå­—ç¬¦ï¼‰
pub fn build_json_request(sql : String, params : Array[String]) -> String {
  // è½¬ä¹‰ SQL ä¸­çš„ç‰¹æ®Šå­—ç¬¦
  let escaped_sql = escape_json_string(sql)
  let json_start = "{\"sql\":\"" + escaped_sql + "\",\"params\":["
  let mut json = json_start
  let mut i = 0
  while i < params.length() {
    if i > 0 {
      json = json + ","
    }
    json = json + "\"" + escape_json_string(params[i]) + "\""
    i = i + 1
  }
  json + "]}"
}

///|
/// è½¬ä¹‰ JSON å­—ç¬¦ä¸²ä¸­çš„ç‰¹æ®Šå­—ç¬¦
fn escape_json_string(s : String) -> String {
  let result = ""
  let mut result_mut = result
  let mut i = 0
  while i < s.length() {
    let c = s[i]
    match c {
      '"' => result_mut = result_mut + "\\\""
      '\\' => result_mut = result_mut + "\\\\"
      '\n' => result_mut = result_mut + "\\n"
      '\r' => result_mut = result_mut + "\\r"
      '\t' => result_mut = result_mut + "\\t"
      _ => result_mut = result_mut + c.to_string()
    }
    i = i + 1
  }
  result_mut
}

///|
/// è§£æ JSON å“åº”ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰
/// 
/// å®ç°åŸºæœ¬çš„ JSON è§£æï¼ˆç®€åŒ–ç‰ˆï¼‰
/// è§£ææ ¼å¼ï¼š{"affected_rows": 1, "success": true} æˆ– {"rows": [...]}
pub fn parse_json_response(body : String) -> @hashmap.HashMap[String, String]? {
  // ç®€åŒ–å®ç°ï¼šæŸ¥æ‰¾ "affected_rows" æˆ– "rows" å­—æ®µ
  // å®é™…å®ç°éœ€è¦ä½¿ç”¨å®Œæ•´çš„ JSON è§£æåº“

  let result : @hashmap.HashMap[String, String] = @hashmap.new()

  // æŸ¥æ‰¾ affected_rows
  match find_json_field(body, "affected_rows") {
    Some(value) => {
      result.set("affected_rows", value)
      Some(result)
    }
    None =>
      // æŸ¥æ‰¾ rowsï¼ˆæŸ¥è¯¢ç»“æœï¼‰
      match find_json_field(body, "rows") {
        Some(_) =>
          // å¦‚æœæœ‰ rows å­—æ®µï¼Œè§£æç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºç¤ºä¾‹
          // å®Œæ•´å®ç°éœ€è¦è§£ææ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ 
          Some(result)
        None => None
      }
  }
}

///|
/// ä» JSON å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾å­—æ®µå€¼ï¼ˆç®€åŒ–å®ç°ï¼‰
fn find_json_field(json : String, field_name : String) -> String? {
  let field_pattern = "\"" + field_name + "\":"
  match find_json_pattern(json, field_pattern) {
    Some(start) => {
      // æ‰¾åˆ°å­—æ®µåï¼Œç»§ç»­æŸ¥æ‰¾å€¼
      let value_start = start + field_pattern.length()
      let mut i = value_start
      // è·³è¿‡ç©ºæ ¼
      while i < json.length() && json[i] == ' ' {
        i = i + 1
      }
      // æŸ¥æ‰¾å€¼çš„å¼€å§‹ï¼ˆå¯èƒ½æ˜¯æ•°å­—æˆ–å­—ç¬¦ä¸²ï¼‰
      if i < json.length() {
        if json[i] == '"' {
          // å­—ç¬¦ä¸²å€¼
          let str_start = i + 1
          let mut str_end = str_start
          while str_end < json.length() && json[str_end] != '"' {
            str_end = str_end + 1
          }
          if str_end < json.length() {
            // æå–å­—ç¬¦ä¸²å€¼ï¼ˆç®€åŒ–ï¼Œä¸è€ƒè™‘è½¬ä¹‰ï¼‰
            Some(extract_substring(json, str_start, str_end))
          } else {
            None
          }
        } else {
          // æ•°å­—å€¼
          let num_start = i
          let mut num_end = num_start
          while num_end < json.length() &&
                json[num_end] >= '0' &&
                json[num_end] <= '9' {
            num_end = num_end + 1
          }
          Some(extract_substring(json, num_start, num_end))
        }
      } else {
        None
      }
    }
    None => None
  }
}

///|
/// æŸ¥æ‰¾å­å­—ç¬¦ä¸²ä½ç½®ï¼ˆHttpDataSource ä¸“ç”¨ï¼‰
fn find_json_pattern(s : String, pattern : String) -> Int? {
  let mut i = 0
  while i <= s.length() - pattern.length() {
    let mut matched = true
    let mut j = 0
    while j < pattern.length() {
      if i + j >= s.length() || s[i + j] != pattern[j] {
        matched = false
        break
      }
      j = j + 1
    }
    if matched {
      return Some(i)
    } else {
      i = i + 1
    }
  }
  None
}

///|
/// æå–å­å­—ç¬¦ä¸²ï¼ˆç®€åŒ–å®ç°ï¼‰
fn extract_substring(s : String, start : Int, end : Int) -> String {
  let result = ""
  let mut result_mut = result
  let mut i = start
  while i < end && i < s.length() {
    result_mut = result_mut + s[i].to_string()
    i = i + 1
  }
  result_mut
}

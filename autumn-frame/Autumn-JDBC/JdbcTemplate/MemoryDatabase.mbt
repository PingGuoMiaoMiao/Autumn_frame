/// MemoryDatabase - å†…å­˜æ•°æ®åº“å®ç°
/// 
/// å®ç°ä¸€ä¸ªç®€å•çš„å†…å­˜æ•°æ®åº“ï¼Œæ”¯æŒåŸºæœ¬çš„ SQL æ“ä½œå’Œäº‹åŠ¡
/// 
/// åŠŸèƒ½ï¼š
/// 1. æ”¯æŒ INSERTã€SELECTã€UPDATEã€DELETE
/// 2. æ”¯æŒåŸºæœ¬çš„äº‹åŠ¡ï¼ˆå¿«ç…§æœºåˆ¶ï¼‰
/// 3. æ”¯æŒ WHERE æ¡ä»¶ï¼ˆç®€åŒ–ç‰ˆï¼‰
/// 
/// æ³¨æ„ï¼š
/// - è¿™æ˜¯ä¸€ä¸ªç®€åŒ–å®ç°ï¼Œç”¨äºæ¼”ç¤ºå’Œæµ‹è¯•
/// - ä¸æ”¯æŒå¤æ‚çš„ SQL è¯­æ³•
/// - äº‹åŠ¡ä½¿ç”¨å¿«ç…§æœºåˆ¶å®ç°

// ========== å¯¼å…¥ä¾èµ– ==========

// ä» RowMapper æ¨¡å—å¯¼å…¥ç±»å‹ï¼ˆåŒä¸€åŒ…å†…ï¼Œç›´æ¥ä½¿ç”¨ï¼‰
// Row ç±»å‹å·²åœ¨ RowMapper.mbt ä¸­å®šä¹‰ï¼špub type Row = @hashmap.HashMap[String, String]
// åœ¨åŒä¸€åŒ…å†…ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ Rowï¼ˆç±»å‹åˆ«åï¼‰ï¼Œä¸éœ€è¦é‡æ–°å®šä¹‰

// ========== æ•°æ®ç»“æ„ ==========

/// SQL è¯­å¥ç±»å‹
pub enum SqlStatement {
  Insert(String, Array[String], Array[String])  // è¡¨å, åˆ—å, å€¼
  Select(String, Array[String], String?)        // è¡¨å, åˆ—å, WHEREæ¡ä»¶
  Update(String, Array[(String, String)], String?)  // è¡¨å, SETå­å¥, WHEREæ¡ä»¶
  Delete(String, String?)                      // è¡¨å, WHEREæ¡ä»¶
}

/// äº‹åŠ¡å¿«ç…§ï¼ˆæ•°æ®å¤‡ä»½ï¼‰
pub struct TransactionSnapshot {
  tables : @hashmap.HashMap[String, @hashmap.HashMap[String, Row]]
}

/// åˆ›å»ºäº‹åŠ¡å¿«ç…§
pub fn TransactionSnapshot::new(tables : @hashmap.HashMap[String, @hashmap.HashMap[String, Row]]) -> TransactionSnapshot {
  { tables, }
}

/// å†…å­˜æ•°æ®åº“
pub struct MemoryDatabase {
  // è¡¨å -> è¡Œæ•°æ®ï¼ˆè¡ŒID -> è¡Œæ•°æ®ï¼‰
  tables : @hashmap.HashMap[String, @hashmap.HashMap[String, Row]]
  
  // äº‹åŠ¡çŠ¶æ€ï¼ˆäº‹åŠ¡ID -> æ•°æ®å¿«ç…§ï¼‰
  transactions : @hashmap.HashMap[String, TransactionSnapshot]
  
  // è¡ŒID è®¡æ•°å™¨ï¼ˆç”¨äºç”Ÿæˆå”¯ä¸€è¡ŒIDï¼‰
  row_id_counter : Int
}

/// åˆ›å»ºå†…å­˜æ•°æ®åº“
pub fn MemoryDatabase::new() -> MemoryDatabase {
  {
    tables: @hashmap.new(),
    transactions: @hashmap.new(),
    row_id_counter: 0
  }
}

/// è·å–è¡Œ ID è®¡æ•°å™¨ï¼ˆç”¨äºç”Ÿæˆå”¯ä¸€è¡Œ IDï¼‰
pub fn MemoryDatabase::get_row_id_counter(self : MemoryDatabase) -> Int {
  self.row_id_counter
}

/// è®¾ç½®è¡Œ ID è®¡æ•°å™¨
pub fn MemoryDatabase::set_row_id_counter(
  self : MemoryDatabase,
  counter : Int
) -> MemoryDatabase {
  { ..self, row_id_counter: counter }
}

// ========== SQL è§£æå™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰ ==========

/// å­—ç¬¦ä¸²å·¥å…·å‡½æ•°
fn has_prefix(s : String, prefix : String) -> Bool {
  if s.length() < prefix.length() {
    false
  } else {
    try {
      s[:prefix.length()] == prefix
    } catch {
      _ => false
    }
  }
}

fn contains(s : String, substr : String) -> Bool {
  let mut i = 0
  let substr_len = substr.length()
  let s_len = s.length()
  while i <= s_len - substr_len {
    try {
      if s[i:i + substr_len] == substr {
        return true
      }
    } catch {
      _ => ()
    }
    i = i + 1
  }
  false
}

fn trim(s : String) -> String {
  // ç®€åŒ–å®ç°ï¼šç§»é™¤å‰åç©ºæ ¼
  // æ³¨æ„ï¼šç”±äº Moonbit å­—ç¬¦ä¸²åˆ‡ç‰‡çš„é™åˆ¶ï¼Œè¿™é‡Œä½¿ç”¨ç®€åŒ–å®ç°
  // å®é™…ä½¿ç”¨ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„å®ç°
  s  // ç®€åŒ–å®ç°ï¼šç›´æ¥è¿”å›åŸå­—ç¬¦ä¸²
}

/// è§£æ SQL è¯­å¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
/// 
/// æ”¯æŒçš„è¯­æ³•ï¼š
/// - INSERT INTO table (col1, col2) VALUES (?, ?)
/// - SELECT * FROM table WHERE id = ?
/// - SELECT col1, col2 FROM table WHERE id = ?
/// - UPDATE table SET col1 = ? WHERE id = ?
/// - DELETE FROM table WHERE id = ?
pub fn parse_sql(sql : String) -> SqlStatement? {
  // ç®€åŒ–å®ç°ï¼šç›´æ¥æ£€æŸ¥å‰ç¼€ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰
  let sql_len = sql.length()
  let has_insert_prefix1 = has_prefix(sql, "INSERT INTO")
  let has_insert_prefix2 = has_prefix(sql, "insert into")
  let has_insert_prefix = has_insert_prefix1 || has_insert_prefix2
  
  let has_select_prefix1 = has_prefix(sql, "SELECT")
  let has_select_prefix2 = has_prefix(sql, "select")
  let has_select_prefix = has_select_prefix1 || has_select_prefix2
  
  let has_update_prefix1 = has_prefix(sql, "UPDATE")
  let has_update_prefix2 = has_prefix(sql, "update")
  let has_update_prefix = has_update_prefix1 || has_update_prefix2
  
  let has_delete_prefix1 = has_prefix(sql, "DELETE FROM")
  let has_delete_prefix2 = has_prefix(sql, "delete from")
  let has_delete_prefix = has_delete_prefix1 || has_delete_prefix2
  
  let has_insert = sql_len >= 11 && has_insert_prefix
  let has_select = sql_len >= 6 && has_select_prefix
  let has_update = sql_len >= 6 && has_update_prefix
  let has_delete = sql_len >= 11 && has_delete_prefix
  
  if has_insert {
    // INSERT INTO table (col1, col2) VALUES (?, ?)
    parse_insert(sql)
  } else if has_select {
    // SELECT * FROM table WHERE id = ?
    parse_select(sql)
  } else if has_update {
    // UPDATE table SET col1 = ? WHERE id = ?
    parse_update(sql)
  } else if has_delete {
    // DELETE FROM table WHERE id = ?
    parse_delete(sql)
  } else {
    None
  }
}

/// æŸ¥æ‰¾å­å­—ç¬¦ä¸²ï¼ˆç®€åŒ–å®ç°ï¼šé€ä¸ªå­—ç¬¦æ¯”è¾ƒï¼‰
fn find(s : String, substr : String) -> Int? {
  let mut i = 0
  let s_len = s.length()
  let substr_len = substr.length()
  while i <= s_len - substr_len {
    // é€ä¸ªå­—ç¬¦æ¯”è¾ƒ
    let mut matched = true
    let mut j = 0
    while j < substr_len {
      let s_char = s[i + j]
      let substr_char = substr[j]
      if s_char != substr_char {
        matched = false
        break
      }
      j = j + 1
    }
    if matched {
      return Some(i)
    }
    i = i + 1
  }
  None
}

/// æŸ¥æ‰¾å­å­—ç¬¦ä¸²ï¼ˆä»æŒ‡å®šä½ç½®å¼€å§‹ï¼Œç®€åŒ–å®ç°ï¼šé€ä¸ªå­—ç¬¦æ¯”è¾ƒï¼‰
fn find_from(s : String, substr : String, start : Int) -> Int? {
  let mut i = start
  let s_len = s.length()
  let substr_len = substr.length()
  while i <= s_len - substr_len {
    // é€ä¸ªå­—ç¬¦æ¯”è¾ƒ
    let mut matched = true
    let mut j = 0
    while j < substr_len {
      let s_char = s[i + j]
      let substr_char = substr[j]
      if s_char != substr_char {
        matched = false
        break
      }
      j = j + 1
    }
    if matched {
      return Some(i)
    }
    i = i + 1
  }
  None
}

/// è§£æ INSERT è¯­å¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
/// 
/// æ”¯æŒæ ¼å¼ï¼šINSERT INTO table (col1, col2) VALUES (?, ?)
/// 
/// æ³¨æ„ï¼šç”±äºå­—ç¬¦ä¸²åˆ‡ç‰‡é™åˆ¶ï¼Œè¿™é‡Œä½¿ç”¨é€ä¸ªå­—ç¬¦è§£æ
fn parse_insert(sql : String) -> SqlStatement? {
  // æ‰¾åˆ° "INSERT INTO" çš„ä½ç½®
  match find(sql, "INSERT INTO") {
    Some(start) => {
      // æ‰¾åˆ°è¡¨åï¼ˆINSERT INTO ä¹‹ååˆ°ç¬¬ä¸€ä¸ª ( ä¹‹å‰ï¼‰
      match find_from(sql, "(", start + 11) {
        Some(table_end) => {
          // æå–è¡¨åï¼ˆè·³è¿‡ç©ºæ ¼ï¼‰
          let mut table_name_start = start + 11
          while table_name_start < table_end && sql[table_name_start] == ' ' {
            table_name_start = table_name_start + 1
          }
          
          // ç®€åŒ–å®ç°ï¼šä½¿ç”¨å›ºå®šå­—ç¬¦ä½ç½®æå–è¡¨å
          let table_name_result = ""
          let mut table_name = table_name_result
          let mut i = table_name_start
          while i < table_end {
            let c = sql[i]
            if c != 32 {  // 32 æ˜¯ç©ºæ ¼çš„ ASCII ç 
              table_name = table_name + c.unsafe_to_char().to_string()
            }
            i = i + 1
          }
          
          // æ‰¾åˆ°åˆ—ååˆ—è¡¨ï¼ˆç¬¬ä¸€ä¸ª ( åˆ°ç¬¬ä¸€ä¸ª )ï¼‰
          match find_from(sql, ")", table_end) {
            Some(cols_end) => {
              // æå–åˆ—åå­—ç¬¦ä¸²
              let mut cols_str = ""
              let mut j = table_end + 1
              while j < cols_end {
                cols_str = cols_str + sql[j].unsafe_to_char().to_string()
                j = j + 1
              }
              let columns = parse_column_list(cols_str)
              
              // æ‰¾åˆ° VALUESï¼ˆæ”¯æŒå¤§å°å†™ä¸æ•æ„Ÿï¼‰
              // å…ˆè·³è¿‡å¯èƒ½çš„ç©ºæ ¼
              let mut search_start = cols_end + 1
              while search_start < sql.length() && sql[search_start] == ' ' {
                search_start = search_start + 1
              }
              
              let mut vals_start : Int? = None
              match find_from(sql, "VALUES", search_start) {
                Some(pos) => vals_start = Some(pos)
                None => {
                  match find_from(sql, "values", search_start) {
                    Some(pos) => vals_start = Some(pos)
                    None => ()
                  }
                }
              }
              
              match vals_start {
                Some(vals_start_pos) => {
                  // æ‰¾åˆ° VALUES åçš„ (ï¼ˆè·³è¿‡å¯èƒ½çš„ç©ºæ ¼ï¼‰
                  let vals_len = 6  // "VALUES" æˆ– "values" çš„é•¿åº¦
                  let mut paren_pos = vals_start_pos + vals_len
                  // è·³è¿‡ç©ºæ ¼
                  while paren_pos < sql.length() && sql[paren_pos] == ' ' {
                    paren_pos = paren_pos + 1
                  }
                  match find_from(sql, "(", paren_pos) {
                    Some(values_open) => {
                      // æ‰¾åˆ°å¯¹åº”çš„ )
                      match find_from(sql, ")", values_open) {
                        Some(values_close) => {
                          // æå–å€¼åˆ—è¡¨ï¼ˆè·³è¿‡ ? å ä½ç¬¦ï¼‰
                          // ç®€åŒ–å®ç°ï¼šåªè®¡ç®—å‚æ•°æ•°é‡
                          let mut count = 0
                          let mut k = values_open + 1
                          while k < values_close {
                            if sql[k] == '?' {
                              count = count + 1
                            }
                            k = k + 1
                          }
                          
                          let values = parse_value_list_from_count(count)
                          
                          if columns.length() == values.length() {
                            Some(SqlStatement::Insert(table_name, columns, values))
                          } else {
                            None
                          }
                        }
                        None => None
                      }
                    }
                    None => None
                  }
                }
                None => None
              }
            }
            None => None
          }
        }
        None => None
      }
    }
    None => None
  }
}

/// ä»å‚æ•°æ•°é‡åˆ›å»ºå€¼åˆ—è¡¨
fn parse_value_list_from_count(count : Int) -> Array[String] {
  let result : Array[String] = []
  let result_mut = result
  let mut i = 0
  while i < count {
    result_mut.push("?")
    i = i + 1
  }
  result_mut
}

/// è§£æ SELECT è¯­å¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
/// 
/// æ”¯æŒæ ¼å¼ï¼š
/// - SELECT * FROM table WHERE id = ?
/// - SELECT col1, col2 FROM table WHERE id = ?
fn parse_select(sql : String) -> SqlStatement? {
  // æ‰¾åˆ° "FROM" çš„ä½ç½®ï¼ˆæ”¯æŒå¤§å°å†™ä¸æ•æ„Ÿï¼‰
  let mut from_pos : Int? = None
  match find(sql, "FROM") {
    Some(pos) => from_pos = Some(pos)
    None => {
      match find(sql, "from") {
        Some(pos) => from_pos = Some(pos)
        None => ()
      }
    }
  }
  
  match from_pos {
    Some(from) => {
      // æå–åˆ—åï¼ˆSELECT å’Œ FROM ä¹‹é—´çš„éƒ¨åˆ†ï¼‰
      let select_part_result = ""
      let mut select_part = select_part_result
      let mut i = 0
      while i < from {
        select_part = select_part + sql[i].unsafe_to_char().to_string()
        i = i + 1
      }
      
      let columns = if has_prefix(select_part, "SELECT *") {
        []  // ç©ºæ•°ç»„è¡¨ç¤º SELECT *
      } else {
        // æå–åˆ—åï¼ˆè·³è¿‡ "SELECT "ï¼‰
        let mut cols_str = ""
          let mut j = 7  // è·³è¿‡ "SELECT "
        while j < from {
          cols_str = cols_str + sql[j].unsafe_to_char().to_string()
          j = j + 1
        }
        parse_column_list(cols_str)
      }
      
      // æ‰¾åˆ°è¡¨åï¼ˆFROM ä¹‹åï¼Œè·³è¿‡ç©ºæ ¼ï¼‰
      let from_start_base = from + 4
      let mut from_start = from_start_base
      while from_start < sql.length() && sql[from_start] == ' ' {
        from_start = from_start + 1
      }
      
      // æŸ¥æ‰¾ WHEREï¼ˆå¦‚æœæœ‰ï¼Œæ”¯æŒå¤§å°å†™ä¸æ•æ„Ÿï¼‰
      let mut where_pos : Int? = None
      match find_from(sql, "WHERE", from_start) {
        Some(pos) => where_pos = Some(pos)
        None => {
          match find_from(sql, "where", from_start) {
            Some(pos) => where_pos = Some(pos)
            None => ()
          }
        }
      }
      
      match where_pos {
        Some(where_pos) => {
          // æå–è¡¨åï¼ˆè·³è¿‡ç©ºæ ¼ï¼Œåªå–åˆ° WHERE ä¹‹å‰ï¼‰
          let table_name_result = ""
          let mut table_name = table_name_result
          let mut k = from_start
          while k < where_pos {
            let c = sql[k]
            if c != 32 {  // 32 æ˜¯ç©ºæ ¼çš„ ASCII ç 
              table_name = table_name + c.unsafe_to_char().to_string()
            }
            k = k + 1
          }
          
          // æå– WHERE å­å¥ï¼ˆè·³è¿‡ WHERE å…³é”®å­—ï¼‰
          let where_clause_result = ""
          let mut where_clause = where_clause_result
          let where_len = 5  // "WHERE" æˆ– "where" çš„é•¿åº¦
          let mut m = where_pos + where_len
          while m < sql.length() {
            where_clause = where_clause + sql[m].unsafe_to_char().to_string()
            m = m + 1
          }
          
          Some(SqlStatement::Select(table_name, columns, Some(where_clause)))
        }
        None => {
          // æ²¡æœ‰ WHERE å­å¥
          let table_name_result = ""
          let mut table_name = table_name_result
          let mut k = from_start
          while k < sql.length() {
            let c = sql[k]
            if c != 32 {  // 32 æ˜¯ç©ºæ ¼çš„ ASCII ç 
              table_name = table_name + c.unsafe_to_char().to_string()
            }
            k = k + 1
          }
          Some(SqlStatement::Select(table_name, columns, None))
        }
      }
    }
    None => None
  }
}

/// è§£æ UPDATE è¯­å¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
/// 
/// æ”¯æŒæ ¼å¼ï¼šUPDATE table SET col1 = ? WHERE id = ?
fn parse_update(sql : String) -> SqlStatement? {
  // æ‰¾åˆ° "SET" çš„ä½ç½®ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰
  let mut set_pos : Int? = None
  let sql_upper = find(sql, "SET")
  let sql_lower = find(sql, "set")
  match sql_upper {
    Some(pos) => set_pos = Some(pos)
    None => {
      match sql_lower {
        Some(pos) => set_pos = Some(pos)
        None => ()
      }
    }
  }
  
  match set_pos {
    Some(set) => {
      // æå–è¡¨åï¼ˆUPDATE ä¹‹ååˆ° SET ä¹‹å‰ï¼‰
      let mut table_name = ""
      let mut i = 7  // è·³è¿‡ "UPDATE "
      while i < set {
        if sql[i] != ' ' {
          table_name = table_name + sql[i].to_string()
        }
        i = i + 1
      }
      
      // æ‰¾åˆ° SET å’Œ WHERE ä¹‹é—´çš„éƒ¨åˆ†
      match find_from(sql, "WHERE", set) {
        Some(where_pos) => {
          // æå– SET å­å¥
          let mut set_clause = ""
          let mut j = set + 3  // è·³è¿‡ "SET"
          while j < where_pos {
            set_clause = set_clause + sql[j].to_string()
            j = j + 1
          }
          
          // æå– WHERE å­å¥
          let mut where_clause = ""
          let mut k = where_pos + 5  // è·³è¿‡ "WHERE"
          while k < sql.length() {
            where_clause = where_clause + sql[k].to_string()
            k = k + 1
          }
          
          let set_pairs = parse_set_clause(set_clause)
          Some(SqlStatement::Update(table_name, set_pairs, Some(where_clause)))
        }
        None => {
          // æ²¡æœ‰ WHERE å­å¥
          let mut set_clause = ""
          let mut j = set + 3  // è·³è¿‡ "SET"
          while j < sql.length() {
            set_clause = set_clause + sql[j].to_string()
            j = j + 1
          }
          let set_pairs = parse_set_clause(set_clause)
          Some(SqlStatement::Update(table_name, set_pairs, None))
        }
      }
    }
    None => None
  }
}

/// è§£æ DELETE è¯­å¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
/// 
/// æ”¯æŒæ ¼å¼ï¼šDELETE FROM table WHERE id = ?
fn parse_delete(sql : String) -> SqlStatement? {
  // æ‰¾åˆ° "FROM" çš„ä½ç½®
  match find(sql, "FROM") {
    Some(from) => {
      let from_start = from + 4  // è·³è¿‡ "FROM"
      
      // æŸ¥æ‰¾ WHERE
      match find_from(sql, "WHERE", from_start) {
        Some(where_pos) => {
          // æå–è¡¨å
          let mut table_name = ""
          let mut i = from_start
          while i < where_pos {
            if sql[i] != ' ' {
              table_name = table_name + sql[i].to_string()
            }
            i = i + 1
          }
          
          // æå– WHERE å­å¥
          let mut where_clause = ""
          let mut j = where_pos + 5  // è·³è¿‡ "WHERE"
          while j < sql.length() {
            where_clause = where_clause + sql[j].to_string()
            j = j + 1
          }
          
          Some(SqlStatement::Delete(table_name, Some(where_clause)))
        }
        None => {
          // æ²¡æœ‰ WHERE å­å¥
          let mut table_name = ""
          let mut i = from_start
          while i < sql.length() {
            if sql[i] != ' ' {
              table_name = table_name + sql[i].to_string()
            }
            i = i + 1
          }
          Some(SqlStatement::Delete(table_name, None))
        }
      }
    }
    None => None
  }
}

/// è§£æåˆ—ååˆ—è¡¨ï¼ˆç®€åŒ–å®ç°ï¼šé€ä¸ªå­—ç¬¦è§£æï¼‰
fn parse_column_list(cols_str : String) -> Array[String] {
  let result : Array[String] = []
  let result_mut = result
  let mut current_col = ""
  let len = cols_str.length()
  let mut i = 0
  while i < len {
    let c = cols_str[i]
    if c == ',' {
      // é‡åˆ°é€—å·ï¼Œä¿å­˜å½“å‰åˆ—å
      let trimmed = trim(current_col)
      if trimmed.length() > 0 {
        result_mut.push(trimmed)
      }
      current_col = ""
    } else if c != ' ' {
      // éç©ºæ ¼å­—ç¬¦ï¼Œæ·»åŠ åˆ°å½“å‰åˆ—å
      current_col = current_col + c.to_string()
    }
    i = i + 1
  }
  // æ·»åŠ æœ€åä¸€ä¸ªåˆ—å
  let trimmed = trim(current_col)
  if trimmed.length() > 0 {
    result_mut.push(trimmed)
  }
  result_mut
}

/// è§£æ SET å­å¥ï¼ˆç®€åŒ–å®ç°ï¼šé€ä¸ªå­—ç¬¦è§£æï¼‰
/// 
/// æ ¼å¼ï¼šcol1 = ?, col2 = ?
fn parse_set_clause(set_clause : String) -> Array[(String, String)] {
  let result : Array[(String, String)] = []
  let result_mut = result
  let mut current_pair = ""
  let len = set_clause.length()
  let mut i = 0
  while i < len {
    let c = set_clause[i]
    if c == ',' {
      // é‡åˆ°é€—å·ï¼Œè§£æå½“å‰å¯¹
      match find(current_pair, "=") {
        Some(eq) => {
          // æå–åˆ—åå’Œå€¼
          let mut col = ""
          let mut j = 0
          while j < eq {
            if current_pair[j] != ' ' {
              col = col + current_pair[j].to_string()
            }
            j = j + 1
          }
          
          let mut val = ""
          let mut k = eq + 1
          while k < current_pair.length() {
            if current_pair[k] != ' ' {
              val = val + current_pair[k].to_string()
            }
            k = k + 1
          }
          
          if col.length() > 0 {
            result_mut.push((col, val))
          }
        }
        None => ()
      }
      current_pair = ""
    } else {
      current_pair = current_pair + c.to_string()
    }
    i = i + 1
  }
  
  // è§£ææœ€åä¸€ä¸ªå¯¹
  if current_pair.length() > 0 {
    match find(current_pair, "=") {
      Some(eq) => {
        let mut col = ""
        let mut j = 0
        while j < eq {
          if current_pair[j] != ' ' {
            col = col + current_pair[j].to_string()
          }
          j = j + 1
        }
        
        let mut val = ""
        let mut k = eq + 1
        while k < current_pair.length() {
          if current_pair[k] != ' ' {
            val = val + current_pair[k].to_string()
          }
          k = k + 1
        }
        
        if col.length() > 0 {
          result_mut.push((col, val))
        }
      }
      None => ()
    }
  }
  
  result_mut
}

// ========== SQL æ‰§è¡Œå¼•æ“ ==========

/// æ‰§è¡Œ SQL è¯­å¥
/// 
/// å‚æ•°ï¼š
/// - sql: SQL è¯­å¥
/// - params: å‚æ•°æ•°ç»„ï¼ˆæ›¿æ¢ ? å ä½ç¬¦ï¼‰
/// 
/// è¿”å›å€¼ï¼š
/// - å½±å“çš„è¡Œæ•°
pub fn MemoryDatabase::execute(
  self : MemoryDatabase,
  sql : String,
  params : Array[String]
) -> (Int, MemoryDatabase) {
  match parse_sql(sql) {
    Some(stmt) => {
      match stmt {
        Insert(table, columns, _values) => {
          let (result, updated_db) = self.execute_insert(table, columns, params)
          (result, updated_db)
        }
        Update(table, set_pairs, where_clause) => {
          let (result, updated_db) = self.execute_update(table, set_pairs, where_clause, params)
          (result, updated_db)
        }
        Delete(table, where_clause) => {
          let (result, updated_db) = self.execute_delete(table, where_clause, params)
          (result, updated_db)
        }
        _ => (0, self)
      }
    }
    None => {
      println("  âŒ [å†…å­˜æ•°æ®åº“] SQL è§£æå¤±è´¥: \{sql}")
      (0, self)
    }
  }
}

/// æ‰§è¡Œ INSERT æ“ä½œ
pub fn MemoryDatabase::execute_insert(
  self : MemoryDatabase,
  table_name : String,
  columns : Array[String],
  params : Array[String]
) -> (Int, MemoryDatabase) {
  // ç¡®ä¿è¡¨å­˜åœ¨
  let new_tables = self.tables
  if not(new_tables.contains(table_name)) {
    new_tables.set(table_name, @hashmap.new())
  }
  
  match new_tables.get(table_name) {
    Some(table) => {
      // ç”Ÿæˆè¡ŒID
      let new_counter = self.row_id_counter + 1
      let row_id = "row_" + new_counter.to_string()
      
      // åˆ›å»ºè¡Œæ•°æ®
      let row : @hashmap.HashMap[String, String] = @hashmap.new()
      row.set("id", row_id)
      
      // å¡«å……åˆ—æ•°æ®
      let mut i = 0
      while i < columns.length() && i < params.length() {
        row.set(columns[i], params[i])
        i = i + 1
      }
      
      // æ’å…¥è¡Œ
      table.set(row_id, row)
      new_tables.set(table_name, table)  // æ›´æ–°è¡¨
      
      let updated_db = {
        ..self,
        tables: new_tables,
        row_id_counter: new_counter
      }
      
      println("  âœ… [å†…å­˜æ•°æ®åº“] INSERT æˆåŠŸ: è¡¨=\{table_name}, è¡ŒID=\{row_id}")
      (1, updated_db)
    }
    None => (0, self)
  }
}

/// æ‰§è¡Œ UPDATE æ“ä½œ
pub fn MemoryDatabase::execute_update(
  self : MemoryDatabase,
  table_name : String,
  set_pairs : Array[(String, String)],
  where_clause : String?,
  params : Array[String]
) -> (Int, MemoryDatabase) {
  match self.tables.get(table_name) {
    Some(table) => {
      let mut updated_count = 0
      let new_table = table
      let updated_tables = self.tables
      
      // ç®€åŒ–å®ç°ï¼šåªæ”¯æŒ WHERE id = ? çš„æƒ…å†µ
      match where_clause {
        Some(where_clause_var) => {
          if contains(where_clause_var, "id =") {
            // æå–å‚æ•°å€¼ï¼ˆç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ id çš„å€¼ï¼‰
            if params.length() > 0 {
              let id_value = params[0]
              
              // æŸ¥æ‰¾è¡Œ
              match new_table.get(id_value) {
                Some(row) => {
                  // æ›´æ–°åˆ—å€¼ï¼ˆä»ç¬¬äºŒä¸ªå‚æ•°å¼€å§‹ï¼‰
                  let mut param_idx = 1
                  set_pairs.iter().each(fn(pair : (String, String)) {
                    let (col, _val) = pair
                    if param_idx < params.length() {
                      row.set(col, params[param_idx])
                      param_idx = param_idx + 1
                    }
                  })
                  
                  new_table.set(id_value, row)
                  updated_tables.set(table_name, new_table)  // æ›´æ–°è¡¨
                  updated_count = 1
                }
                None => ()
              }
            }
          }
        }
        None => {
          // æ²¡æœ‰ WHERE å­å¥ï¼Œæ›´æ–°æ‰€æœ‰è¡Œ
          new_table.iter().each(fn(entry : (String, Row)) {
            let (_id, row) = entry
            let mut param_idx = 0
            set_pairs.iter().each(fn(pair : (String, String)) {
              let (col, _val) = pair
              if param_idx < params.length() {
                row.set(col, params[param_idx])
                param_idx = param_idx + 1
              }
            })
            updated_count = updated_count + 1
          })
          updated_tables.set(table_name, new_table)  // æ›´æ–°è¡¨
        }
      }
      
      if updated_count > 0 {
        println("  âœ… [å†…å­˜æ•°æ®åº“] UPDATE æˆåŠŸ: è¡¨=\{table_name}, æ›´æ–°è¡Œæ•°=\{updated_count}")
      }
      
      let updated_db = {
        ..self,
        tables: updated_tables
      }
      (updated_count, updated_db)
    }
    None => {
      println("  âŒ [å†…å­˜æ•°æ®åº“] è¡¨ä¸å­˜åœ¨: \{table_name}")
      (0, self)
    }
  }
}

/// æ‰§è¡Œ DELETE æ“ä½œ
pub fn MemoryDatabase::execute_delete(
  self : MemoryDatabase,
  table_name : String,
  where_clause : String?,
  params : Array[String]
) -> (Int, MemoryDatabase) {
  match self.tables.get(table_name) {
    Some(table) => {
      let mut deleted_count = 0
      let new_table = table
      let updated_tables = self.tables
      
      // ç®€åŒ–å®ç°ï¼šåªæ”¯æŒ WHERE id = ? çš„æƒ…å†µ
      match where_clause {
        Some(where_clause_var) => {
          if contains(where_clause_var, "id =") {
            // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ id çš„å€¼
            if params.length() > 0 {
              let id_value = params[0]
              match new_table.get(id_value) {
                Some(_row) => {
                  new_table.remove(id_value)
                  updated_tables.set(table_name, new_table)  // æ›´æ–°è¡¨
                  deleted_count = 1
                }
                None => ()
              }
            }
          }
        }
        None => {
          // æ²¡æœ‰ WHERE å­å¥ï¼Œåˆ é™¤æ‰€æœ‰è¡Œ
          deleted_count = new_table.length()
          new_table.clear()
          updated_tables.set(table_name, new_table)  // æ›´æ–°è¡¨
        }
      }
      
      if deleted_count > 0 {
        println("  âœ… [å†…å­˜æ•°æ®åº“] DELETE æˆåŠŸ: è¡¨=\{table_name}, åˆ é™¤è¡Œæ•°=\{deleted_count}")
      }
      
      let updated_db = {
        ..self,
        tables: updated_tables
      }
      (deleted_count, updated_db)
    }
    None => {
      println("  âŒ [å†…å­˜æ•°æ®åº“] è¡¨ä¸å­˜åœ¨: \{table_name}")
      (0, self)
    }
  }
}

/// æŸ¥è¯¢æ•°æ®
/// 
/// å‚æ•°ï¼š
/// - sql: SELECT è¯­å¥
/// - params: å‚æ•°æ•°ç»„
/// 
/// è¿”å›å€¼ï¼š
/// - æŸ¥è¯¢ç»“æœè¡Œåˆ—è¡¨
pub fn MemoryDatabase::query(
  self : MemoryDatabase,
  sql : String,
  params : Array[String]
) -> Array[Row] {
  match parse_sql(sql) {
    Some(stmt) => {
      match stmt {
        Select(table_name, columns, where_clause) => {
          self.execute_select(table_name, columns, where_clause, params)
        }
        _ => []
      }
    }
    None => {
      println("  âŒ [å†…å­˜æ•°æ®åº“] SQL è§£æå¤±è´¥: \{sql}")
      []
    }
  }
}

/// æ‰§è¡Œ SELECT æ“ä½œ
pub fn MemoryDatabase::execute_select(
  self : MemoryDatabase,
  table_name : String,
  columns : Array[String],
  where_clause : String?,
  params : Array[String]
) -> Array[Row] {
  match self.tables.get(table_name) {
    Some(table) => {
      let results : Array[Row] = []
      let results_mut = results
      
      table.iter().each(fn(entry : (String, Row)) {
        let (row_id, row) = entry
        let mut matched = true
        
        // åº”ç”¨ WHERE æ¡ä»¶ï¼ˆç®€åŒ–å®ç°ï¼‰
        match where_clause {
          Some(where_clause_var) => {
            if contains(where_clause_var, "id =") {
              // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ id çš„å€¼
              if params.length() > 0 {
                matched = row_id == params[0]
              }
            }
          }
          None => matched = true
        }
        
        if matched {
          // é€‰æ‹©åˆ—ï¼ˆç®€åŒ–å®ç°ï¼šå¦‚æœ columns ä¸ºç©ºï¼Œè¿”å›æ‰€æœ‰åˆ—ï¼‰
          if columns.length() == 0 {
            results_mut.push(row)
          } else {
            // åˆ›å»ºæ–°è¡Œï¼ŒåªåŒ…å«æŒ‡å®šçš„åˆ—
            let filtered_row : @hashmap.HashMap[String, String] = @hashmap.new()
            columns.iter().each(fn(col : String) {
              match row.get(col) {
                Some(val) => filtered_row.set(col, val)
                None => ()
              }
            })
            results_mut.push(filtered_row)
          }
        }
      })
      
      if results_mut.length() > 0 {
        println("  âœ… [å†…å­˜æ•°æ®åº“] SELECT æˆåŠŸ: è¡¨=\{table_name}, è¿”å›è¡Œæ•°=\{results_mut.length()}")
      }
      results_mut
    }
    None => {
      println("  âŒ [å†…å­˜æ•°æ®åº“] è¡¨ä¸å­˜åœ¨: \{table_name}")
      []
    }
  }
}

// ========== äº‹åŠ¡æ”¯æŒ ==========

/// å¼€å§‹äº‹åŠ¡ï¼ˆåˆ›å»ºæ•°æ®å¿«ç…§ï¼‰
pub fn MemoryDatabase::begin_transaction(
  self : MemoryDatabase,
  transaction_id : String
) -> MemoryDatabase {
  // åˆ›å»ºæ•°æ®å¿«ç…§
      let snapshot_tables : @hashmap.HashMap[String, @hashmap.HashMap[String, Row]] = @hashmap.new()
  
  self.tables.iter().each(fn(table_entry) {
    let (table_name, table) = table_entry
      let snapshot_table : @hashmap.HashMap[String, Row] = @hashmap.new()
      
      table.iter().each(fn(row_entry) {
        let (row_id, row) = row_entry
        // åˆ›å»ºè¡Œçš„æ·±æ‹·è´ï¼ˆç®€åŒ–å®ç°ï¼‰
        let snapshot_row : @hashmap.HashMap[String, String] = @hashmap.new()
        row.iter().each(fn(col_entry : (String, String)) {
          let (col, val) = col_entry
          snapshot_row.set(col, val)
        })
        snapshot_table.set(row_id, snapshot_row)
      })
    
    snapshot_tables.set(table_name, snapshot_table)
  })
  
  let snapshot = TransactionSnapshot::new(snapshot_tables)
  let new_transactions = self.transactions
  new_transactions.set(transaction_id, snapshot)
  
  println("  ğŸ”µ [å†…å­˜æ•°æ®åº“] å¼€å§‹äº‹åŠ¡: \{transaction_id}")
  
  {
    ..self,
    transactions: new_transactions
  }
}

/// æäº¤äº‹åŠ¡ï¼ˆç§»é™¤å¿«ç…§ï¼‰
pub fn MemoryDatabase::commit_transaction(
  self : MemoryDatabase,
  transaction_id : String
) -> MemoryDatabase {
  match self.transactions.get(transaction_id) {
    Some(_snapshot) => {
      // ç§»é™¤å¿«ç…§ï¼ˆæ•°æ®å·²åº”ç”¨ï¼‰
      let new_transactions = self.transactions
      new_transactions.remove(transaction_id)
      println("  âœ… [å†…å­˜æ•°æ®åº“] æäº¤äº‹åŠ¡: \{transaction_id}")
      {
        ..self,
        transactions: new_transactions
      }
    }
    None => {
      println("  âš ï¸  [å†…å­˜æ•°æ®åº“] äº‹åŠ¡ä¸å­˜åœ¨: \{transaction_id}")
      self
    }
  }
}

/// å›æ»šäº‹åŠ¡ï¼ˆæ¢å¤æ•°æ®å¿«ç…§ï¼‰
pub fn MemoryDatabase::rollback_transaction(
  self : MemoryDatabase,
  transaction_id : String
) -> MemoryDatabase {
  match self.transactions.get(transaction_id) {
    Some(snapshot) => {
      // æ¢å¤æ•°æ®å¿«ç…§
      let new_transactions = self.transactions
      new_transactions.remove(transaction_id)
      println("  âŒ [å†…å­˜æ•°æ®åº“] å›æ»šäº‹åŠ¡: \{transaction_id}")
      {
        ..self,
        tables: snapshot.tables,
        transactions: new_transactions
      }
    }
    None => {
      println("  âš ï¸  [å†…å­˜æ•°æ®åº“] äº‹åŠ¡ä¸å­˜åœ¨: \{transaction_id}")
      self
    }
  }
}

/// æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ´»åŠ¨äº‹åŠ¡
pub fn MemoryDatabase::has_transaction(
  self : MemoryDatabase,
  transaction_id : String
) -> Bool {
  self.transactions.contains(transaction_id)
}


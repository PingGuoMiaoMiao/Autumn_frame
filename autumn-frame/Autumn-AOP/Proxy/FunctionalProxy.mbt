/// FunctionalProxy - å‡½æ•°å¼ä»£ç†
/// 
/// ä¸ä½¿ç”¨ç±»ä»£ç†ï¼Œè€Œæ˜¯ä½¿ç”¨å‡½æ•°åŒ…è£…å™¨å®ç° AOP
/// 
/// ä¼˜ç‚¹ï¼š
/// - âœ… ä¸éœ€è¦åŠ¨æ€ç”Ÿæˆç±»
/// - âœ… é€‚ç”¨äºå‡½æ•°å¼ç¼–ç¨‹é£æ ¼
/// - âœ… æ€§èƒ½å¥½ï¼ˆç¼–è¯‘æ—¶ç¡®å®šï¼‰
/// 
/// ç¼ºç‚¹ï¼š
/// - âŒ ä¸èƒ½ä»£ç†ç»“æ„ä½“çš„æ–¹æ³•
/// - âŒ éœ€è¦æ‰‹åŠ¨åŒ…è£…æ¯ä¸ªå‡½æ•°

// ========== å‡½æ•°å¼ä»£ç†å®ç° ==========

///|
/// å‡½æ•°æ‹¦æˆªå™¨
pub type FunctionInterceptor = (String, Array[String]) -> Unit // (function_name, args)

///|
/// å‡½æ•°ä»£ç†åŒ…è£…å™¨
/// 
/// æ³¨æ„ï¼šç”±äºåŒ…å«å‡½æ•°ç±»å‹ï¼Œæ— æ³• derive Eq å’Œ Show
pub struct FunctionalProxy {
  before_interceptors : Array[FunctionInterceptor]
  after_interceptors : Array[FunctionInterceptor]
}

///|
/// åˆ›å»ºå‡½æ•°ä»£ç†
pub fn FunctionalProxy::new() -> FunctionalProxy {
  { before_interceptors: [], after_interceptors: [] }
}

///|
/// æ·»åŠ  Before æ‹¦æˆªå™¨
pub fn FunctionalProxy::add_before(
  self : FunctionalProxy,
  interceptor : FunctionInterceptor,
) -> FunctionalProxy {
  let new_interceptors = self.before_interceptors
  new_interceptors.push(interceptor)
  {
    before_interceptors: new_interceptors,
    after_interceptors: self.after_interceptors,
  }
}

///|
/// æ·»åŠ  After æ‹¦æˆªå™¨
pub fn FunctionalProxy::add_after(
  self : FunctionalProxy,
  interceptor : FunctionInterceptor,
) -> FunctionalProxy {
  let new_interceptors = self.after_interceptors
  new_interceptors.push(interceptor)
  {
    before_interceptors: self.before_interceptors,
    after_interceptors: new_interceptors,
  }
}

///|
/// åŒ…è£…æ— å‚æ•°æ— è¿”å›å€¼çš„å‡½æ•°
pub fn FunctionalProxy::wrap_unit(
  self : FunctionalProxy,
  original_fn : () -> Unit,
  function_name : String,
) -> () -> Unit {
  fn() -> Unit {
    // Before Advice
    let _ = self.before_interceptors.map(fn(interceptor) {
      interceptor(function_name, [])
    })

    // è°ƒç”¨åŸå§‹å‡½æ•°
    original_fn()

    // After Advice
    let _ = self.after_interceptors.map(fn(interceptor) {
      interceptor(function_name, [])
    })

  }
}

///|
/// åŒ…è£…æœ‰è¿”å›å€¼çš„å‡½æ•°
pub fn[T] FunctionalProxy::wrap(
  self : FunctionalProxy,
  original_fn : () -> T,
  function_name : String,
) -> () -> T {
  fn() -> T {
    // Before Advice
    let _ = self.before_interceptors.map(fn(interceptor) {
      interceptor(function_name, [])
    })

    // è°ƒç”¨åŸå§‹å‡½æ•°
    let result = original_fn()

    // After Advice
    let _ = self.after_interceptors.map(fn(interceptor) {
      interceptor(function_name, [])
    })
    result
  }
}

///|
/// åŒ…è£…æœ‰å‚æ•°çš„å‡½æ•°
/// 
/// æ³¨æ„ï¼šéœ€è¦å‚æ•°ç±»å‹å®ç° Show traitï¼ˆç”¨äºæ—¥å¿—ï¼‰
pub fn[T] FunctionalProxy::wrap_args(
  self : FunctionalProxy,
  original_fn : (T) -> Unit,
  function_name : String,
  args_to_string : (T) -> String,
) -> (T) -> Unit {
  fn(args : T) -> Unit {
    // Before Advice
    let _ = self.before_interceptors.map(fn(interceptor) {
      interceptor(function_name, [args_to_string(args)])
    })

    // è°ƒç”¨åŸå§‹å‡½æ•°
    original_fn(args)

    // After Advice
    let _ = self.after_interceptors.map(fn(interceptor) {
      interceptor(function_name, [args_to_string(args)])
    })

  }
}

///|
/// åŒ…è£…å®Œæ•´å‡½æ•°ï¼ˆå‚æ•° + è¿”å›å€¼ï¼‰
/// 
/// æ³¨æ„ï¼šç”±äºç±»å‹é™åˆ¶ï¼Œæ­¤å‡½æ•°éœ€è¦å‚æ•°å’Œè¿”å›å€¼éƒ½å®ç° Show trait
pub fn[Args, Ret] FunctionalProxy::wrap_full(
  self : FunctionalProxy,
  original_fn : (Args) -> Ret,
  function_name : String,
  args_to_string : (Args) -> String,
) -> (Args) -> Ret {
  fn(args : Args) -> Ret {
    // Before Advice
    let _ = self.before_interceptors.map(fn(interceptor) {
      interceptor(function_name, [args_to_string(args)])
    })

    // è°ƒç”¨åŸå§‹å‡½æ•°
    let result = original_fn(args)

    // After Advice
    let _ = self.after_interceptors.map(fn(interceptor) {
      interceptor(function_name, [args_to_string(args)])
    })
    result
  }
}

///|
/// ä½¿ç”¨ç¤ºä¾‹
pub fn example_usage() -> Unit {
  // åŸå§‹å‡½æ•°
  let original_fn = fn(x : Int) -> Int { x * 2 }

  // åˆ›å»ºä»£ç†
  let proxy1 = FunctionalProxy::new()
  let proxy2 = proxy1.add_before(fn(func_name, args) {
    println("  ğŸ”µ [ä»£ç†] Before \{func_name}, args=\{args}")
  })
  let proxy3 = proxy2.add_after(fn(func_name, args) {
    println("  âœ… [ä»£ç†] After \{func_name}, args=\{args}")
  })

  // åŒ…è£…å‡½æ•°ï¼ˆéœ€è¦æä¾›å‚æ•°è½¬å­—ç¬¦ä¸²çš„å‡½æ•°ï¼‰
  let proxied_fn = proxy3.wrap_full(original_fn, "multiply_by_two", fn(
    x : Int,
  ) -> String {
    x.to_string()
  })

  // è°ƒç”¨ä»£ç†å‡½æ•°
  let result = proxied_fn(5)
  println("  ğŸ“Š [ä»£ç†] ç»“æœ: \{result}")
}
